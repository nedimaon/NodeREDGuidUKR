| [На головну](../) | [Розділ](README.md) |
| ----------------- | ------------------- |
|                   |                     |

## Шаблони Mustache

[Посилання на оригінал](https://mustache.github.io/mustache.5.html) 

  `mustache` -- описові шаблони без логіки.

### Опис

Mustache можна використовувати для HTML, конфігураційних файлів, вихідного коду -- чого завгодно. Він працює, через розширюючі теги в шаблоні, використовуючи значення, надані в **хеші** (**hash**) або об'єкті.

Ми називаємо це "без логіки", тому що немає виразів типу `if-else`  та циклів `for`. Натомість є лише **теги**. Деякі теги замінюються значенням, деякі нічим, а інші послідовністю значень. Цей документ пояснює різні типи Mustache .

### Приклад

Приклад шаблону Mustache:

```json
Hello {{name}}
You have just won {{value}} dollars!
{{#in_ca}}
Well, {{taxed_value}} dollars, after taxes.
{{/in_ca}}
```

Якщо хеш буде такими:

```json
{
  "name": "Chris",
  "value": 10000,
  "taxed_value": 10000 - (10000 * 0.4),
  "in_ca": true
}
```

То результат буде наступним:

```json
Hello Chris
You have just won 10000 dollars!
Well, 6000.0 dollars, after taxes.
```

### Типи тегів

Теги позначені подвійними фігурними дужками (звідси **mustaches**, **вуса**). Наприклад `{{person}}` - це тег, як і `{{#person}} `. В обох прикладах ми би називали `person` як ключ (key) або ключ тегу (key tag). Поговоримо про різні типи тегів.

#### Variables (змінні)

Найбільш загальний тип тегу - це **змінна** (**variable**). Тег `{{name}}` у базовому шаблоні спробує знайти ключ `name` у поточному контексті. Якщо немає ключа `name`, перевірятимуться рекурсивно батьківські контексти. Якщо буде досягнуто верхнього контексту, а ключ `name` все ще не знайдений, нічого не буде виведено.

Усі змінні за замовчуванням екранований HTML. Якщо ви хочете повернути неекранований HTML, скористайтеся "потрійними вусами":`{{{name}}}`.

Ви також можете використовувати `&` для неекранування змінної: `{{& name}}`. Це може бути корисно при зміні роздільників (див. "Встановити роздільник" нижче).

За замовчуванням погана змінна повертає порожній рядок. Зазвичай це можна налаштувати у вашій бібліотеці Mustache. Наприклад, версія Ruby з Mustache підтримує виняток у цій ситуації.

Шаблон:

```json
* {{name}}
* {{age}}
* {{company}}
* {{{company}}}
```

з хешом:

```json
{
  "name": "Chris",
  "company": "<b>GitHub</b>"
}
```

поверне:

```json
* Chris
*
* &lt;b&gt;GitHub&lt;/b&gt;
* <b>GitHub</b>
```

#### Sections (секції)

Секції відображають блоки тексту один або кілька разів, залежно від значення ключа в поточному контексті.

Секція починається з `#` і закінчується `/`. Тобто, `{{#person}}` починає секцію "person", тоді як `{{/ person}}` закінчує її.

Поведінка секції означується значенням ключа.

**Значення False або порожній список**

Якщо ключ `person` існує і має значення false або порожнього списку, HTML між `#` і `/` не відображатиметься.

Наприклад при шаблоні:

```
Shown.
{{#person}}
  Never shown!
{{/person}}
```

і хеші:

```
{
  "person": false
}
```

показуватиме:

```
Shown.
```

**Не порожній список**

Якщо ключ `person` існує і має ненульове значення, HTML між між `#` і `/` відображатиметься один або кілька разів.

Коли значення є не порожнім списком, текст у блоці буде відображатися один раз для кожного елемента у списку. Контекст блоку буде встановлений у поточному елементі для кожної ітерації. Таким чином ми можемо перебирати колекції.

Наприклад, при шаблоні:

```
{{#repo}}
  <b>{{name}}</b>
{{/repo}}
```

Та значенні хешу:

```
{
  "repo": [
    { "name": "resque" },
    { "name": "hub" },
    { "name": "rip" }
  ]
}
```

Виведення буде наступним:

```
<b>resque</b>
<b>hub</b>
<b>rip</b>
```

Оскільки тег `repo` є не порожнім списком, то в секції буде виведено значення кожного `name` обрамленого з обох боків тегом <b>.

**Lambdas**

Коли значенням є об'єкт, що викликається, наприклад функція або лямбда, об'єкт буде викликаний та переданий тудт блок тексту. Текст, що передається, є літеральним блоком, без рендерингу. `{{теги}}` не буде розширено - лямбда повинна робити це самостійно. Таким чином ви можете реалізувати фільтри або кешування.

Наприклад, шаблон:

```
{{#wrapped}}
  {{name}} is awesome.
{{/wrapped}}
```

При хеші:

```
{
  "name": "Willy",
  "wrapped": function() {
    return function(text, render) {
      return "<b>" + render(text) + "</b>"
    }
  }
}
```

Поверне:

```
<b>Willy is awesome.</b>
```

**Не-FALSE значення**

Коли значення є відмінним від FALSE, але не є списком, воно буде використовуватися як контекст для одного виконання блоку.

Наприклад шаблон:

```
{{#person?}}
  Hi {{name}}!
{{/person?}}
```

При хеші:

```
{
  "person?": { "name": "Jon" }
}
```

видасть:

```
Hi Jon!
```

#### Inverted Sections

Інвертована секція з `^` і закінчується `/`. Тобто `{{^ person}}` починає інвертовану секцію "person", тоді як `{{/person}}`закінчує її.

Звичайні секції можуть бути використані для виконання тексту один чи більше разів на основі значення ключа, тоді як інвертовані секції можуть відображати текст один раз на основі інвертованого значення ключа. Тобто вони будуть виконані, якщо ключ FALSE, помилковий або є порожнім списком.

Template:

```
{{#repo}}
  <b>{{name}}</b>
{{/repo}}
{{^repo}}
  No repos :(
{{/repo}}
```

Hash:

```
{
  "repo": []
}
```

Output:

```
No repos :(
```

#### Comments

Коментарі починаються з `!` і ігноруються. Наступний шаблон:

```
<h1>Today{{! ignore me }}.</h1>
```

дасть 

```
<h1>Today.</h1>
```

Коментарі можуть містити нові рядки.

#### Partials

Partials begin with a greater than sign, like `{{> box}}`.

Партії виконуються під час виконання (на відміну від часу компіляції), тому можливі рекурсивні партії. Просто уникайте нескінченних петель.

Вони також успадковують контекст виклику. В той час як у файлі [ERB](http://en.wikipedia.org/wiki/ERuby) у вас може бути таке:

```
<%= partial :next_more, :start => start, :size => size %>
```

Mustache потребує таке:

```
{{> next_more}}
```

Чому? Тому що файл `next_more.mustache` успадкує методи` size` та `start` з контексту виклику.

Таким чином, ви можете подумати про партії як про включення, імпорт, розширення шаблонів, вкладених шаблонів або підшаблонів, хоча це в прямому сенсі не так.

For example, this template and partial:

```
base.mustache:
<h2>Names</h2>
{{#names}}
  {{> user}}
{{/names}}

user.mustache:
<strong>{{name}}</strong>
```

Can be thought of as a single, expanded template:

```
<h2>Names</h2>
{{#names}}
  <strong>{{name}}</strong>
{{/names}}
```

#### Set Delimiter

Теги Set Delimiter починаються зі знаку `=` та змінюють роздільники тегів із `{{` та `}}` на власні рядки.

Розглянемо наступний надуманий приклад:

```
* {{default_tags}}
{{=<% %>=}}
* <% erb_style_tags %>
<%={{ }}=%>
* {{ default_tags_again }}
```

Тут ми маємо список з трьома пунктами. Перший елемент використовує стиль тегу за замовчуванням, другий використовує стиль erb, визначений тегом Set Delimiter, а третій повертається до стилю за замовчуванням після ще одного обявлення Set Delimiter.

Згідно з  [ctemplates](http://google-ctemplate.googlecode.com/svn/trunk/doc/howto.html),  це "корисно для таких мов, як TeX, де в тексті можуть виникати подвійні дужки та є незручними для використання розмітки. "

Спеціальні роздільники не можуть містити пробіл або знак рівності.