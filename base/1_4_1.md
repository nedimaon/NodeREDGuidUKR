| [На головну](../)                   | [Розділ](README.md)                   |
| ----------------------------------- | ------------------------------------- |
| [<- Конфігурування безпеки](1_4.md) | [Робота з вузлом Function ->](1_5.md) |

## Основні вузли 

Палітра Node-RED включає стандартний набір вузлів, які є основними будівельними блоками для створення потоків. Цей розділ висвітлює основний набір, про який ви повинні знати. Ряд інших вузлів описано у відповідному розділі довідника. 



Всі вузли включають документацію, яку ви можете переглянути на вкладці Info бічної панелі коли вибираєте вузол.

### Inject (ініціювання повідомлення)

![](media/inject.png)Вузол **Inject** може бути використаний для ручного запуску потоку, натиснувши кнопку вузла в редакторі. Він також може використовуватися для автоматичного запуску потоків через регулярні інтервали часу або в запланований час.

У налаштуваннях вузла можна вказати тему повідомлення (`Topic`) та значення `Payload` (рис.1.40). 

![](media/1_40.png)

рис.1.40. Налаштування вузла Inject

У новіших версіях можливості вузла `Inject` значно розширилися. Тепер в ньому можна задавати будь яку властивість повідомлення а також вказувати налаштування запуску в певні дні тижня по календарю. 

![](media/inject_cnfg.png) 

рис. Налаштування вузлу `Inject` у Node-RED версії  1.1.1.

Для payload можна встановити різні типи:

-   відмітку часу (Timestamp) -- значення в мілісекундах з 1 січня 1970 року
-   константу: рядок (`string`), число (`number`), логічне значення (`boolean`), Buffer (бінарний зміст) або JSON 
-   значення [контекстів](1_7.md): потоку (`flow context`) або глобального контексту (`global context`)
-   `$env variable` -- змінну середовища Node.js
-   `J:expression` -- [JSONata](../jsonata/README.md) перетворення

При налаштуванні інтервалу можна вказати значення до 596 годин (24 дні). За необхідності вибирати великі інтервали можна скористатися вузлами планування (scheduler).

### Debug (вивести на відлагодження)

![](media/debug.png)Вузол Debug може використовуватися для відображення повідомлень на бічній панелі Debug у редакторі, середовища виконання або зображення статусу вузла.

![](media/debug_cfg.png)

Бічна панель забезпечує структурований перегляд повідомлень, що надсилаються, що полегшує вивчення цього повідомлення. Поряд з кожним повідомленням бічна панель налагодження включає в себе інформацію про час надходження повідомлення та місце з якого вузлу воно надіслане. Натискання на ідентифікатор вихідного вузла покаже цей вузол у робочій області.

Кнопку на вузлі можна використовувати для ввімкнення або вимкнення його виходів. Рекомендується відключити або видалити будь-які вузли Debug, які не використовуються.

Цей вузол також може бути налаштований для відправлення всіх повідомлень до журналу середовища виконання (`system console`) зокрема у вікно консолі, або для надсилання коротких (до 32 символів) повідомлень про статус налагоджуваного вузла (`node status`). Також при виводі можна використовувати перетворення  [JSONata](../jsonata/README.md) .

### Complete

![](media/complete.png) Запускає потік, коли інший вузол завершує оброблення повідомлення.

![](media/complete_cfg.png)

Наприклад, це можна використовувати разом з вузлом, що не має виходу (вихідного порту), наприклад вузлом відправлення електронної пошти, для того, щоб продовжити потік після його оброблення.

Цей вузол повинен бути налаштований для оброблення події для вибраних вузлів у потоці. На відміну від вузла `Catch`, він не забезпечує режим "оброблення всіх" ('handle all'), який автоматично застосовується до всіх вузлів потоку.

Не всі вузли генерують цю подію - це буде залежати від того, чи були вони реалізовані для підтримки цієї функції, яка була введена в Node-RED 1.0.

### Catch (обробник помилок)

![](media/catch.png)Ловить помилки виконання інших вузлів у тому самому потоці і формує повідомлення з інформацією про них.

![](media/catch_cfg.png)

Вихідне повідомлення містить властивості: 

- error.message (*string*) - повідомлення про помилку.
- error.source.id (*string*) - ідентифікатор вузлу, що згенерував помилку.
- error.source.type (*string*) - тип вузлу, що згенерував помилку.
- error.source.name (*string*) - ім'я вузла, якщо є, який згенерував момилку.

![](media/catch_msg.png)

Якщо вузол видає помилку під час обробки повідомлення, потік, як правило, зупиняється (halt). Цей вузол може бути використаний для вилову цих помилок та оброблення їх виділеним потоком.

За замовчуванням вузол буде знаходити помилки, згенеровані будь-яким вузлом в одному потоці (вкладці з потоками). Крім того, він може бути націлений на конкретні вузли або налаштований лише на помилки, які ще не були виловлені.

При генерування помилки, усі вузли Cathc отримують повідомлення.

Якщо помилка передається в підпотоці, помилка буде оброблена будь-якими вузлами Catch в підпотоці. Якщо такої немає, помилка поширюватиметься на весь потік (вкладку), на якій знаходиться екземпляр підпотоку.

Якщо повідомлення вже має властивість `error`, воно копіюється в ` _error`.

### Function (функція)

![](media/function.png)Вузол Function дозволяє запускати код JavaScript для обробки повідомлень, які передаються через нього. Детальніше про використання вузла функцій розглянуто у розділі [Робота з вузлом Function](1_5.md).

### Change (зміна повідомлення в потоці)

![](media/change.png)Вузол Change можна використовувати для зміни властивостей повідомлення та контексту (потоку та глобального) без необхідності вдаватися до вузла Function. 

Кожен вузол може бути налаштований з декількома операціями, які застосовуються у вказаному порядку. Доступні операції:

-   **Set** - встановити властивість. Значення може бути з різними типами або може бути взяте з існуючого повідомлення або властивості контексту.
-   **Change** - пошук і заміна частин властивості повідомлення.
-   **Move** - перемістити або перейменувати властивість.
-   **Delete** -- видалити властивість.

Для кожного правила вказується що саме треба змінити: властивість змінної `msg. ` , контекст потоку (`flow.`) або глобальний контекст (`global.`). 

![](media/change_cfg.png)

Для `set` вказується яке саме значення необхідно присвоїти властивості. Це може бути константа, відмітка часу, значення властивості змінної `msg`, контексту чи змінної середовища, значення також може бути результатом виразу [JSONata](https://jsonata.org/) . JSONata - це декларативна мова запитів та перетворень для даних JSON. Детальніше про зміну повідомлення за допомогою цього вузла Ви можете [прочитати за посиланням](1_6.md#зміна-властивостей-повідомлення).

Наступний приклад реалізовує бітовий меандр з дискретністю 1 секунда.   

![](media/change_exmpl.png)

Вузол `Init` ініціалізує потік, який через вузол `change` записує в значення контексту потоку `flow.on` значенням `false` при старті потоку (через 0.1 сек після старту). Далі вузол `flow.on` періодично кожну секунду формує повідомлення в яке записує плинне значення потоку `flow.on`. Далі вузол Change виконує два правила:

-  записує в контекст потоку `flow.on` інвертоване значення `payload` використовуючи JSONata функцію `$not`
- записує  в `payload` значення контексту потоку    

### Switch (перемикач повідомлення)

![](media/switch.png)Вузол Switch дозволяє передавати повідомлення до різних гілок потоку, оцінюючи набір правил для кожного повідомлення. 

Цей вузол налаштовано за допомогою властивості для перевірки - це може бути або властивість повідомлення (message property), або властивість контексту (context property). Також в якості першого аргументу для порівняння може використовуватися вираз JSONata або змінна середовища.

![](media/switch_conf.png)

Існує чотири типи правил:

-   **Value** - правила оцінюються для зконфігурованої властивості

-   **Sequence** - правила можуть бути використані для послідовності повідомлень, наприклад, ті, які створені вузлом `Split`

-   може бути надана JSONata **Expression**, який буде використаний для перевірки всього повідомлення і буде відповідати, якщо вираз повертає значення true .

-   **Otherwise** - правило може бути використане для відповідності, якщо жодне з попередніх правил не співпало.

Вузол переведе повідомлення на всі виходи, що відповідають правилам відповідності (`checking all rules`). Але він також може бути налаштований таким чином, щоб зупинити перевірку правил одразу, як знайдеться правило, що виконується (`stopping after first match`).

Правило `is empty` передається для рядків, масивів та буферів, що мають довжину 0, або об'єктів, які не мають властивостей. Він не передає значення`null`  або `undefined` .

За замовчуванням вузол не змінює властивість `msg.parts` повідомлень, які є частиною послідовності.

Параметр  `recreate message sequences` можна включити для створення нових послідовностей повідомлень для кожного правила, яке відповідає. У цьому режимі вузол буде буферувати всю вхідну послідовність, перш ніж надсилати нові послідовності. Налаштування виконання `nodeMessageBufferMaxLength` можна використовувати для обмеження кількості буферів вузлів повідомлень.

### Range (масштабування)

![](media/range.png)Масштабує числові значення відповідно до вказаних вхідних та вихідних діапазонів.

Масштабування відбувається відповідно до налаштованих вхідного діапазону (input range) та цільового діапазону (target range). Вхідне та вихідне значення мусить бути числового формату, інакше вузол намагатиметься перетворити його в такий.  

![](media/range_cfg.png)

Цей вузол буде лінійно масштабувати отримане значення. 

За замовчуванням виставлений режим Action рівним *Scale the message property*, при якому результат не обмежується діапазоном, визначеним у вузлі. *Scale and limit to target range* означає, що результат ніколи не буде виходити за межі діапазону, визначеного в цільовому діапазоні (target range). Режим *Scale and wrap within the target range* означає, що результат буде завершено в межах цільового діапазону.

Наприклад при вхідному діапазоні (0 - 10) та вихідному (0 - 100) за різних режимів будуть наступні результати на виході, при вході рівним 12.

| mode  | input | output |
| ----- | ----- | ------ |
| scale | 12    | 120    |
| limit | 12    | 100    |
| wrap  | 12    | 20     |

### Template (шаблон)

![](media/template.png)Вузол Template може використовуватися для створення тексту з властивостей повідомлення з використанням означеного шаблону Mustache. Для формування результату він використовує шаблонну мову [Mustache](mustach.md) , який в якості контексту приймає властивості об'єкта `msg`. Наприклад, шаблон:

![](media/must1.png)

замінить `payload` з значенням властивості повідомлення `payload`.

![](media/template_cfg.png)

Ще один приклад. Якщо шаблон буде вказано як:

```
Hello {{payload.name}}. Today is {{date}}
```

і на вхід вузла прийде повідомлення що вміщує:

```json
{
  date: "Monday",
  payload: {
    name: "Fred"
  }
}
```

Результатом буде:

```json
Hello Fred. Today is Monday
```

Окрім об'єкта повідомлення `msg`, в шаблоні можна використовувати контексти потоку або глобальний контекст. Для цього достатньо використовувати `{{flow.name}}` або `{{global.name}}`, або для збереженого контексту `store` використовувати `{{flow[store].name}}` або `{{global[store].name}}`.

За замовчуванням, Mustache замінить не-текстові символи та HTML-теги в значення замінники. Щоб зупинити це, ви можете скористатися потрійними "вусами": `{{{payload}}}`. 

Mustache підтримують прості цикли у списках. Наприклад, якщо `msg.payload` містить масив імен, таких як: ` ["Nick", "Dave", "Claire"]`, то наступний шаблон 

```json
<ul>
{{#payload}}
  <li>{{.}}</li>
{{/payload}}
</ul>
```

створить список HTML імен:

```json
<ul>
  <li>Nick</li>
  <li>Dave</li>
  <li>Claire</li>
</ul>
```

Наведений вище приклад базується на Mustache секціях, що починаються з `#` і завершуються `/`. Якщо тег секції (у даному прикладі це `payload`) є непустим списком, то буде виводитися кожен елемент списку. 

Вузол встановить у вихідне повідомлення або в контекстну властивість (вибирається в Property) результат виконання шаблону. Якщо шаблон генерує дійсний вміст JSON або YAML, його можна налаштувати для аналізу результату на відповідний об\'єкт JavaScript.

Шаблон можна передавати на вхід як `msg.template`(*string*), якщо в конфігураційному вузлі не вказаний шаблон. 

### Status (стан вузлу)

![](media/status.png)Показує стан (status message) вказаних або усіх вузлів в потоці. 

За замовчуванням вузол повідомляє про стан всіх вузлів на одній вкладці робочого простору (потоку). Він може бути налаштований для повідомлення про стан окремих вузлів (рис.1.41).

![](media/1_41.png)

рис.1.41. Вибір вузла, для якого означується стан.

Цей вузол не генерує `payload`, він формує об'єкт `status`, з наступними властивостями:

-   text (string) -- статусний текст
-   fill -- колір статусної піктограми
-   shape -- форма статусної піктограми
-   source.type (string) -- тип вузла, що передає статус
-   source.id (string) -- `id` вузла, що передає статус
-   source.name (string) -- ім'я, якщо є, вузла що передає статус

![](media/status_exmpl.png)

### Link In та Link Out (Посилання) 

![](media/link_in.png)![](media/link_out.png)

Створюють віртуальні з'єднання між потоками. Вузол може бути з\'єднаний з будь-яким посиланням у вузлі, який існує на будь-якій вкладці. Після підключення вони поводяться так, ніби вони з\'єднані між собою.

Провідники між вузлами зв\'язку відображаються тільки при виборі вузла зв\'язку. Якщо до інших вкладок є будь-які зв'язки, віртуальний вузол показує, який можна натиснути, щоб перейти до відповідної вкладки.

![](media/links_exmpl.png)

Link не можуть створюватися в/з підпотоків (subflows).

### Delay (затримка)

![](media/delay.png)Робить затримку для кожного повідомлення, що проходить через вузол, або обмежує швидкість, з якою вони можуть пройти. 

![](media/Delay_conf.png)

рис. Налаштування вузла Delay

Якщо налаштовано на затримку повідомлень (delay messages), інтервал затримки може бути фіксованим значенням, випадковим значенням у межах діапазону або динамічно заданим для кожного повідомлення. Кожне повідомлення затримується незалежно від будь-якого іншого повідомлення, але залежно від часу його надходження.

Якщо налаштовано для обмеження швидкості повідомлень (rate limiting), їх доставка розподіляється на встановлений часовий період. Статус показує кількість повідомлень, які наразі знаходяться в черзі. При бажанні він може відкинути проміжні повідомлення по мірі їх надходження.

Обмеження швидкості може бути застосовано до всіх повідомлень або згрупувати їх відповідно до їх значення `msg.topic`. При групуванні проміжні повідомлення автоматично скидаються. На кожному часовому інтервалі вузол може або випустити останнє повідомлення для всіх тем, або випустити останнє повідомлення для наступної теми.

Властивості вхідних повідомлень можуть керувати вузлом:

- `delay` (*number*) - Встановлює затримку в мілісекундах, яку слід застосувати до повідомлення. Ця опція застосовується лише в тому випадку, якщо вузол налаштований так, щоб дозволити повідомлення заміняти налаштований інтервал затримки за замовчуванням.
- `reset` - Якщо в отриманому повідомленні для цієї властивості встановлено будь-яке значення, всі невідправлені повідомлення, утримувані вузлом, очищаються без надсилання.
- `flush` - Якщо отримане повідомлення має цю властивість встановлену у будь-яке значення, всі невідправлені повідомлення, утримувані вузлом, надсилаються негайно.

### Trigger

![](media/trigger.png)Якщо цей вузол спрацьовує, надсилається перше повідомлення, а потім друге через певний проміжок часу. Є кілька режимів роботи:

- wait for -- відправка двох повідомлень з вказаною затримкою 
- wait to be reset -- відправка одного повідомлення і блокування пересилання повідомлення, аж до повідомлення з властивістю скидання  
- resend it every -- відправка повідомлень з вказаною періодичністю  

![](media/trigger_conf.png)

Вхідне повідомлення може мати властивість `reset` , яке скидує тригер.

Цей вузол можна використовувати для створення тайм-ауту в потоці. За замовчуванням, коли він отримує повідомлення, він надсилає повідомлення із `payload` рівним `1`. Потім він чекає 250 мс, перш ніж надсилати друге повідомлення з `payload`  `0`. Це може бути використано, наприклад, для миготіння світлодіода, прикріпленого до штифта Raspberry Pi GPIO.

Корисні навантаження кожного відправленого повідомлення можуть бути налаштовані на різні значення, включаючи можливість нічого не надсилати. Наприклад, встановивши початкове повідомлення на `nothing`  та вибравши опцію для продовження таймера з кожним отриманим повідомленням, вузол буде виконувати функцію таймера watchdog ; тільки відправлення повідомлення, якщо нічого не було отримано протягом встановленого інтервалу.

Якщо встановлено тип *string*, вузол підтримує синтаксис шаблону [Mustache](mustach.md) .

`Reset the trigger if`: Якщо вузол отримає повідомлення із властивістю `reset`  або `payload`, що відповідає встановленому у налаштуванні вузлу значення, будь-який час очікування або повторення, що виконується, буде видалено, і повідомлення не запуститься.

Статус вказує, що вузол активний. Якщо використовується декілька потоків, статус вказує кількість потоків, що утримуються.

Наступний приклад показує, як можна з двох тригерів зробити мультивібратор, який видає на виході з періодичністю 1 секунду 0 або 1. Скидування мультивібратору відбувається вузлом з назвою `stop`, який виставляє повідомлення з полем `reset`

![](media/trigger_exmpl.png)

### exec (запуск команди)

![](media/exec.png)Запускає системну команду і повертає значення з її виходу. Вузол можна налаштувати для очікування завершення команди, або надіслати повідомлення на вихід, коли команда його генерує. Команда, що виконується, може бути налаштована у вузлі або надана отриманим повідомленням .

![](media/exec_conf.png)

###### Входи:

`payload` (*string*)- якщо налаштовано (опцією `msg.payload`), буде додано (конкатенація) до виконаної команди. 

`kill` (*string*)-  тип сигналу для знищення процесу для надсилання до exec. Про типи сигналів для POSIX можна подивитися [за посиланням](https://uk.wikipedia.org/wiki/%D0%A1%D0%B8%D0%B3%D0%BD%D0%B0%D0%BB_(%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D1%96%D0%B9%D0%BD%D1%96_%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B8)). 

`pid` (*number* або *string*)- process ID існуючого процесу для його знищення.

###### Виходи:

1- Standard output

- `payload` - стндартний вихід команди

- `rc` (*object*) - тільки для режиму exec, копія коду повернення об'єкту, також доступний на виході 3 

2 - Standard error

- `payload` - стандартна помилка команди 

- `rc` (*object*) - тільки для режиму exec, копія коду повернення об'єкту, також доступний на виході 3 

3 - Return code

- payload (*object*) -- об'єкт, який містить код повернення, і має властивості  `message` та `signal` .

За замовчуванням вузол використовує системний виклик `exec`, який викликає команду, чекає її завершення і повертає результат. Наприклад, успішна команда повинна мати код повернення `{code: 0}`.

За бажанням можна використовувати режим `spawn`, який повертає вихід з `stdout` та `stderr` під час виконання команди, як правило, по одному рядку за раз. Після завершення він повертає об'єкт на 3-му виході. Наприклад, успішна команда повинна повернути `{code: 0}`.

Помилки можуть повернути додаткову інформацію на 3-му виході `msg.payload`, наприклад, рядок ` message`, `signal` string.

Команда, що виконується, означується всередині вузла, з можливістю додавання `msg.payload` та подальшим набором параметрів.

Команди або параметри з пробілами слід укладати в лапки - `"This is a single parameter"`

Повернене `payload`, як правило, є *string*, якщо тільки не виявлені символи, що не належать до UTF8, у цьому випадку це буде *buffer*.

Піктограма стану вузла та PID буде видима, поки вузол активний. Зміни в цьому можна прочитати вузлом `Status` .

Відправлення `msg.kill` знищить один активний процес. `msg.kill` має бути рядок, що містить тип сигналу, що надсилається, наприклад, ` SIGINT`, `SIGQUIT` або ` SIGHUP`. За замовчуванням `SIGTERM`, якщо встановлено порожній рядок.

Якщо у вузлі працює більше одного процесу, тоді також слід встановити `msg.pid` зі значенням PID, який потрібно знищити.

Якщо в полі `Timeout` вказане значення, тоді, якщо процес не завершився, коли минуло вказане число секунд, процес буде автоматично знищений

Порада: якщо ви запускаєте додаток Python, можливо, вам доведеться скористатися параметром `-u`, щоб зупинити завантаження виводу.

[Російськомовна версія](http://wikihandbk.com/wiki/Node-RED:%D0%91%D0%B8%D0%B1%D0%BB%D0%B8%D0%BE%D1%82%D0%B5%D0%BA%D0%B8/node-red/Exec)

### rbe (гістерезис, нечутливість)

![](media/rbe.png)Звіт "Report by Exception" -- пропускає повідомлення лише у випадку зміни корисного навантаження. Він також може блокувати або ігнорувати, поки значення не зміниться на певну величину.

![](media/rbe_conf.png)

###### Входи:

`payload` (*number | string | (object)* -- у режимі RBE приймає числа, рядки та прості об'єкти. Інші режими повинні забезпечувати значення, що аналізується.

`topic` (*string*) --  якщо вказано, функція буде працювати на основі теми.

`reset`(*any*) -- якщо встановлено, очищає збережене значення для вказаного `msg.topic` або всіх тем, якщо `msg.topic` не вказано.

###### Виходи:

`payload`(*as per input*) --  якщо спрацьовує, вихід буде таким самим, як і вхід.

У режимі RBE цей вузол блокується, поки значення `msg.payload`, (або вибраної властивості) не буде відрізнятися від попереднього. Якщо потрібно, він може ігнорувати intial значення, щоб не надсилати нічого на початку.

У режимах зони нечутливості (Deadband) вхідне значення повинно містити проаналізоване число і блокуватися, якщо зміна не перевищує + або - значення нечутливості від попереднього значення.

Зона нечутливості також підтримує % - надсилається лише у випадку, якщо вхід відрізняється більш ніж на `x%` від початкового значення.

Режими Narrowband  блокує вихід, якщо зміна вхідного значення перевищує + або - розрив смуги від попереднього значення. Наприклад, корисно для ігнорування несправного датчика.

І Deadband  і Narrowband дозволяють порівнювати порівняно з попереднім дійсним вихідним значенням, ігноруючи, таким чином, будь-які значення поза діапазоном; або попереднє вхідне значення, яке скидає задану точку, дозволяючи таким чином поступовий дрейф (мертвий діапазон), або ступінчаста зміна (вузькосмугова).

**Примітка:** Це працює на основі `msg.topic`. Це означає, що один вузол rbe може обробляти декілька різних тем одночасно.

### Comment

![](media/comment.png)Вузол для додавання коментарів в потік.

Панель редагування приймає синтаксис Markdown. Текст буде переданий на цю інформаційну сторінку панелі.

![](media/comment_exmpl.png)

Слід відмітити, що коментар можна написати для кожного вузлу. Тому цей вузол можна використовувати для коментування всього потоку.

### Unknown (невідомий)

![](../media/unknown.png)Цей вузол невідомого типу для встановленого Node-RED.

Такі вузли можуть з'явитися тоді, коли Ви імпортуєте потік з вузлами, модулі для яких відсутні в Node-RED. Графічно це матиме наступний вигляд:   

![](media/unknown_exmpl.png)

*Якщо Ви робите розгортання з таким вузлом у цьому стані, його конфігурація буде збережена, але потік не буде виконуватися до тих пір, поки не буде встановлено відсутній тип.*

Використовуйте опцію `Menu - Manage Palette` для пошуку та встановлення вузлів, або **npm install <module> ** для встановлення будь-яких відсутніх модулів, перезапустіть Node-RED та повторно імпортуйте вузли.

Можливо, цей тип вузла вже встановлений, але він має залежності з іншими модулями, які відсутні. Перевірте журнал запуску NED-RED на наявність повідомлень про помилки, пов’язані з відсутнім типом вузла.

В іншому випадку вам слід зв’язатися з автором потоку, щоб отримати копію відсутнього типу вузла.

[Робота з вузлом Function ->](1_5.md) 